# 什么是索引

为什么需要索引：

- 没有索引时，数据库要查询某条记录，只能从头到尾一条条“全表扫描”（性能慢）。

- 有了索引，数据库就能根据索引结构快速定位到你要的数据，**大大提升查询效率**。索引 = 快速查找的目录

MySQL 中最常用的索引底层结构是 **B+树（平衡树）**：

- 数据库会按照你设定的“索引列”，建立一棵排序好的树形结构。

优点：
- 查找时像二分查找一样迅速。
- 加速查询、排序、分组和聚合、连接，提高WHERE条件性能

缺点：
- **额外占用存储空间**。
- 建得太多或不合理，会拖慢写入性能。

建议设置为索引的字段应该具备：
1. **高选择性**
2. **经常参与查询（WHERE / JOIN / GROUP BY）**
3. **字段类型不宜过长**
4. **更新频率不太高**

删除索引 和 删除约束 区别：

| 对象       | 删除内容               | 本质         | 示例            |
| -------- | ------------------ | ---------- | ------------- |
| **删除约束** | 删除规则（比如不能重复、必须存在等） | **约束逻辑**   | 删除唯一约束、主键、外键等 |
| **删除索引** | 删除加速查询的数据结构        | **性能优化工具** | 删除某列或组合列的索引结构 |

^d81b03

有些约束创建的时候会自动创建索引，删除的时候自动删除（唯一约束、主键），有的不会（外键）

# 覆盖索引

示例：
```mysql
CREATE TABLE product (
  id INT PRIMARY KEY,
  name VARCHAR(100),
  -- 其他字段
);

-- 创建普通索引
CREATE INDEX idx_name ON product(name);
```

查询语句：
```mysql
select id from product where id > 1  and name like 'i%';
```
执行过程中使用了普通索引（name）
## InnoDB的索引结构

InnoDB 有两种索引：

| 索引类型           | 说明                           |
| -------------- | ---------------------------- |
| **聚簇索引（主键索引）** | 主键索引的叶子节点就是**整行数据**          |
| **二级索引（普通索引）** | 叶子节点只保存**索引列 + 主键值**，不包含整行数据 |

## 什么是覆盖索引

如果查询中使用到的字段，**全部都能从某个索引中得到，不需要回表到原表**，就叫“覆盖索引”。

> 在你这个查询中，普通索引 `idx_name` 虽然只索引了 `name`，但是叶子节点会**额外存储主键值 `id`**，这是 InnoDB 的特点！

所以虽然你查的是 `id`，但实际上：

- 从 `name` 的 B+ 树叶子节点中，就能直接获取对应的主键 `id`
- 不需要再回到主键索引（即“回表”）去拿数据

如果SELECT的字段不是id，就需要回表

## 为什么这个例子中有性能差异？

在这个例子中二者都不需要回表，但是使用普通索引速度更快？
### 方式一：走普通索引 `name`

MySQL 会用 `idx_name` 普通索引（name, id） 来查：

- 利用 `name LIKE 'i%'` 进行快速范围查找
- 查到的叶子节点中包含主键 `id`
- 查询结果正好是 `id`，可以直接返回（覆盖索引 ✅）
- 不用回主键索引找整行数据

**效率高！因为只访问一棵 B+ 树（`idx_name`）**
### 方式二：走主键索引 `id`
 
虽然主键 `id` 的 B+ 树可以快速定位符合 `id > 1` 的数据，**但不能用索引加速 `name like 'i%'` 这个条件！**

所以执行过程是：

- 先根据 `id > 1` 走主键索引找到一大堆数据
- 然后要**一条条记录取出 `name` 字段**，再判断 `name LIKE 'i%'` 是否成立（要比对字符串）
- 相当于对大量数据做了“过滤判断” → 成本高！

📌 重点：这时候 `name` 条件就变成“**不能用索引加速的条件**”，只能**逐行判断**

---

### 对比总结：

> **虽然主键索引本身就包含整行数据，不需要回表，但它**不能用来加速 `name like 'i%'` 这个条件**，反而导致多读数据、多做判断，整体成本就高了。**

而普通索引 `name` 虽然不是主键，但它能提前筛掉大部分无关数据，**配合覆盖索引机制，查得更快！**

## 不同存储引擎的差异
### InnoDB vs MyISAM：覆盖索引的区别

| 特性         | InnoDB         | MyISAM                  |
| ---------- | -------------- | ----------------------- |
| 是否支持聚簇索引   | ✅ 是            | ❌ 否                     |
| 覆盖索引优势     | ✅ 非常明显（能避免回表）  | ❌ 覆盖索引没明显优势             |
| 普通索引叶子节点内容 | **索引字段 + 主键值** | **索引字段 + 数据文件的指针（偏移量）** |
| 回表成本       | 高（需再查主键B+树）    | 低（直接根据偏移量读取）            |

---

### InnoDB 中的覆盖索引为什么高效？

InnoDB 的普通索引叶子节点 **不存整行数据**，但它会额外存 **主键值**。

> ✅ 如果你查询的字段正好都在这个普通索引里 → 就是**覆盖索引**，**不需要回主键索引的 B+ 树**。

⚠️ 否则就要“**回表**”，根据主键值再去主键索引找整行。

因此，**避免回表 → 节省一次B+树查询 → 提高效率**

---

### MyISAM 的表现就不同了

MyISAM 没有聚簇索引，所有索引（包括主键）都是独立的 B+ 树，**叶子节点只保存数据行的物理地址**（类似偏移量）。

所以：

- 即使是普通索引，**也得根据地址再读一遍磁盘取整行数据**
- 但是！这个“回表”只是**直接读磁盘地址，不是查第二棵B+树**，开销其实小一些

📌 所以在 MyISAM 中：

> “覆盖索引”的优势并不明显，甚至数据库也不太在意你是否用覆盖索引

---

### 总结一下

|问题|InnoDB|MyISAM|
|---|---|---|
|覆盖索引能显著提升性能吗？|✅ 是，避免回表成本高|❌ 效果不明显|
|普通索引查不到的字段要“回表”吗？|✅ 要，查主键B+树|✅ 要，读磁盘地址|
|优化器更倾向于选覆盖索引？|✅ 是|❌ 不一定|

---

### 补充建议：

- 如果你用的是 InnoDB（现在几乎默认），**善用覆盖索引会让查询快很多**，比如：
    
    ```sql
    SELECT id FROM user WHERE name = 'Alice';
    ```
    
    给 `name` 建索引，就能变成覆盖索引（因为 id 会跟着存）。
    
- 如果你真的用的是 MyISAM，**就没必要为了覆盖索引去调整索引结构**。