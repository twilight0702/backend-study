---
网址: https://xiaolincoding.com/mysql/base/how_select.html#mysql-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84
github地址: https://github.com/xiaolincoder/CS-Base/blob/main/mysql/base/how_select.md
---
# MySQL的两层结构

Server层和存储引擎层

- **Server 层负责建立连接、分析和执行 SQL**。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。

- **存储引擎层负责数据的存储和提取**。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始，InnoDB 成为了 MySQL 的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。

# 执行一条SELECT语句全过程

## 1. 连接器

### 全过程

1. 连接MySQL服务器（经过TCP三次握手连接）
2. 验证用户名和密码（不正确会报错）
3. 获取用户权限+保存（后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限逻辑的判断）
	- 所以，如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置
### 查看MySQL 服务被多少个客户端连接

```mysql
show processlist
```

### 空闲连接会一直占用着吗

MySQL 定义了空闲连接的==最大空闲时长==，由 `wait_timeout` 参数控制的，默认值是 8 小时（28800 秒），如果空闲连接超过了这个时间，连接器就会自动将它断开

也可以==手动断开连接==，使用的是 kill connection + id 的命令

```mysql
mysql> kill connection +6;
Query OK, 0 rows affected (0.00 sec)
```

### 连接数限制

MySQL 服务支持的最大连接数由 max_connections 参数控制，比如我的 MySQL 服务默认是 151 个，超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”

### 连接分类

#### 分类
- **长连接**：连接之后可以执行多条sql语句
- **短链接**：连接后只执行一条sql语句

#### 优劣
- 长连接的好处就是可以减少建立连接和断开连接的过程，所以一般是推荐使用长连接
- 但是，使用长连接后可能会==占用内存增多==，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。如果长连接累计很多，将导致 MySQL 服务占用内存太大，有可能会被系统强制杀掉，这样会发生 MySQL 服务异常重启的现象

#### 如何解决长连接占用内存的问题？
1. 定期断开长连接
2. 客户端主动重置连接
	- 当客户端执行了一个很大的操作后，在代码里调用` mysql_reset_connection` ==接口函数==来重置连接，达到释放内存的效果。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态
## 2. 查询缓存

> MySQL 8.0 版本直接将查询缓存删掉了，也就是说 MySQL 8.0 开始，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了

> 对于 MySQL 8.0 之前的版本，如果想关闭查询缓存，我们可以通过将参数 query_cache_type 设置成 DEMAND

==这里说的查询缓存是 server 层的，也就是 MySQL 8.0 版本移除的是 server 层的查询缓存，并不是 Innodb 存储引擎中的 buffer pool==

连接器的工作完成后，客户端就可以向 MySQL 服务发送 SQL 语句了，MySQL 服务收到 SQL 语句后，就会解析出 SQL 语句的第一个字段，看看是什么类型的语句。如果 SQL 是查询语句（select 语句），MySQL 就会先去查询缓存（Query Cache）里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。

如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。如果查询的语句没有命中查询缓存中，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中

缺点：对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了，相当于缓存了个寂寞

## 3. 解析SQL（解析器）

### 3.1 词法分析

MySQL 会根据你输入的字符串识别出关键字出来，构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、where 条件等等

例如，对于以下 SQL：
```mysql
SELECT name FROM users WHERE age > 18;
```

词法分析器会识别出以下 Token：

`[SELECT] [name] [FROM] [users] [WHERE] [age] [>] [18] [;]`

这一步的作用是：

- 将 SQL 字符串切分为关键字、表名、字段名、操作符等元素；
- 为后续语法分析做准备；
- 遇到非法字符时立即报错（如不支持的符号等）。
### 3.2 语法分析

根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。
如果我们输入的 SQL 语句语法不对，就会在解析器这个阶段报错。

> 注意，表不存在或者字段不存在，并不是在解析器里做的

## 4. 执行SQL

### 4.1 预处理器

- 检查 SQL 查询语句中的表或者字段是否存在；
- 将 `select *` 中的 `*` 符号，扩展为表上的所有列；

### 4.2 优化器

**优化器主要负责将 SQL 查询语句的执行方案确定下来**，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引，会考虑：
- 选择性：用哪个字段筛选后数据更少
- 是否能用覆盖索引（能减少 I/O）
- 是否需要回表（二级索引如果没覆盖字段，就要去主键索引找原始数据）

[[索引#什么是索引|什么是索引]]

要想知道优化器选择了哪个索引，我们可以在查询语句最前面加个 `explain` 命令，这样就会输出这条 SQL 语句的执行计划，然后执行计划中的 key 就表示执行过程中使用了哪个索引。如果查询语句的执行计划里的 key 为 null 说明没有使用索引，那就会全表扫描（type = ALL），这种查询扫描的方式是效率最低档次的
[[索引#覆盖索引|举例和覆盖索引]]

### 4.3 执行器

确定了执行方案后，就开始真正执行语句。在执行的过程中，执行器就会和存储引擎交互了，交互是以数据行为单位的

以下是三种方式执行过程：
#### 主键索引查询

```sql
select * from product where id = 1;
```

这条查询语句的查询条件用到了主键索引，而且是等值查询，同时主键 id 是唯一，不会有 id 相同的记录，所以优化器决定选用访问类型为 const 进行查询，也就是使用主键索引查询一条记录，那么执行器与存储引擎的执行流程是这样的：

- 执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为是用主键来等值查询`id` ，所以优化器知道：**最多只可能有一条记录**，所以优化器选择的[[访问类型|访问类型]]为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 `id = 1` 交给存储引擎，**让存储引擎定位符合条件的第一条记录**。
- 存储引擎通过主键索引的 B+ 树结构定位到 id = 1 的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器；
- 执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录。
- 执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1 的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。

至此，这个语句就执行完成了。
