---
时间: 2025.4.25
---
有些组织是p2p，有些是集权的

# 数据结构框架

## 概览

1. **数据集（Data Set）**：
   - 表示为 `< D, R >`，其中 `D` 代表数据元素，`R` 代表数据元素之间的关系。

2. **访问模式（Access Patterns）**：
   - 数据集可以通过不同的访问模式进行查询，包括：
     - **A. 点查询（Point Query）**：查询特定数据点。
     - **B. 范围查询（Range Query）**：查询在某个范围内的数据。
     - **C. 存在查询（Existence Query）**：查询某个数据是否存在。

3. **映射到计算机系统架构（Mapped into Computer Systems）**：
   - 数据集可以映射到不同的计算机系统架构中，包括：
     - **A. 集中式架构（Centralized Architecture）**：所有数据处理集中在一个中心位置。
     - **B. 分散式架构（Decentralized Architecture）**：数据处理分布在多个位置。
     - **C. 分布式架构（Distributed Architecture）**：数据和处理分布在多个节点上。
     - **D. 单一架构（Single Architecture）**：单一的系统架构。

4. **遍历存储空间（Traverse over Storage Space）**：
   - 数据结构在存储空间中的遍历方式：
     - **数据结构（Data Structure）**：
       - **原始数据结构（Primitive）**：包括整数、字符、浮点数、指针、实数和布尔值。
       - **静态数组（Static Array）**：固定大小的数组。
       - **非原始数据结构（Non Primitive）**：
         - **线性（Linear）**：如动态数组。
         - **非线性（Non Linear）**：如树（Tree）和图（Graph）。

图中展示了数据结构如何从数据集通过不同的访问模式和存储空间遍历方式映射到计算机系统中，并实现不同的系统架构。

A decentralized system is a special kind of a distributed one with important constraints on interactions among system nodes.
分散式系统是一种特殊的分布式系统，它对系统节点之间的交互有重要的约束。

有很多文档，需要找到其中的一个，如何访问？
- 思想：关键词检索
- 实现方式：倒排表 inverted table
快速但是效果有限
-> 如何构建高效且有效的推荐系统？
- 使用深度学习
	- 最大的挑战是有效
	- Embedding + MLP

如果是有很多图片要找到一张图片的相似图片？
- 如何用倒排表实现？
	- ### 🧩 Step 1：提取图像局部特征

比如用 SIFT、ORB、SURF 等传统图像特征提取算法，对每张图提取多个 keypoints 特征（每张图可能有几百个小 patch）：

`image1.jpg → [f1, f2, ..., f120]  ← 每个f是128维的SIFT向量`

---

### 🧩 Step 2：构建“视觉词典”（Visual Vocabulary）

使用 **K-Means** 对所有图片的所有特征聚类成 `K` 类（如 K=1000）：

`SIFT 特征 → KMeans 聚类 → 每类为一个“视觉词”（Visual Word）`

你就得到了一个“词典”：

`Visual Word 0, 1, ..., 999`

每张图片现在可以用“这些词出现了几次”来表示 —— 变成了一个稀疏向量。

---

### 🧩 Step 3：建立倒排表

**倒排表结构如下：**

`VisualWord_17 → [img2, img8, img12] VisualWord_43 → [img1, img3, img9] ...`

即：某个视觉词出现在哪些图片中。

可以加上“在该图中出现的频次”或“TF-IDF 权重”。

---

### 🧩 Step 4：查询流程（找相似图）

1. 对查询图提取 SIFT 特征
    
2. 把这些特征映射到视觉词（通过KMeans聚类中心最近匹配）
    
3. 找出这些视觉词对应的图像集合（倒排表查找）
    
4. 对候选图做 **BoW 向量 + 余弦相似度** 排序
    
5. 返回得分最高的Top-K图像
    

---

## 📌 举个例子（小型视觉词典）：

假设你构建了一个包含5个视觉词的词典：

`Visual Word ID: 0   1   2   3   4`

某张图的视觉词统计是：

`img_A:     [3, 0, 5, 1, 0]  img_B:     [0, 2, 0, 4, 1]  img_C:     [1, 0, 4, 0, 0]`  

假设你查询的图是：[1, 0, 3, 1, 0]，那系统从词0、2、3 找倒排：

`0 → [img_A, img_C]   2 → [img_A, img_C]   3 → [img_A, img_B]`  

候选图像为：[img_A, img_B, img_C]，再做相似度排序就好。

---

## 🔧 适合使用倒排表的场景

|适用场景|原因|
|---|---|
|小图像库（几万张以内）|计算量可控|
|图像内容相似性不是很复杂|BoVW 特征表示足够了|
|查询速度要求很快|倒排表非常快|
|无 GPU，不能跑大模型|全用 CPU 实现|

---

## ❌ 不适合的场景

- 图像语义差别细微（猫 vs 虎 vs 狮子）
    
- 图像高层语义需求（风格、情感）
    
- 图像数量极大（百万以上）
    
- 要考虑图像上下文、跨模态（图+文）
    

---

## 🔍 补充：倒排表 vs 深度向量检索（如Faiss）

|对比点|倒排表（BoVW）|深度向量（CNN+Faiss）|
|---|---|---|
|精度|中等|高（可微调）|
|速度|快（少量图）|快（百万级）|
|可解释性|好（词频可见）|差（向量黑盒）|
|特征类型|局部点（SIFT）|全图语义（CNN）|
|工具链|OpenCV + Numpy|PyTorch + Faiss|

（上课这部分又重新理了关系（第二节课开头），回头再听听？）

（跳过了NLP部分）

# 为什么增强数据结构是重要的

## 课件内容

### 动态顺序统计（Dynamic order statistics）

- **OS-SELECT(i, S)**：这个操作返回动态集合 S 中第 i 小的元素。例如，如果 i=3，则返回集合中第三小的元素。
    
- **OS-RANK(x, S)**：这个操作返回元素 x 在集合 S 中排序后的秩（即位置）。例如，如果 x 是集合中第5小的元素，则返回5。
    

### 主要思想

- **IDEA: Use a red-black tree for the set S, but keep subtree sizes in the nodes.**：主要思想是使用红黑树（Red-Black Tree）来存储集合 S，同时在每个节点中保存子树的大小。红黑树是一种自平衡二叉查找树，能够在 O(logn) 时间内完成插入、删除和查找操作。
    

### 节点表示

- **Notation for nodes: key size**：节点表示为一个圆圈，其中包含两个部分：
    
    - **key**：表示节点中存储的键值。
        
    - **size**：表示以该节点为根的子树中包含的元素数量。
        
## 示例

### ✨ 问题背景

假设你有一个**动态集合** `S`（可以随时插入、删除元素），你希望能高效地支持两个操作：

---

#### ✅ OS-SELECT(i, S)：

> 返回集合 `S` 中 **第 `i` 小的元素**。

举例：

```text
S = {2, 4, 6, 10, 13}
OS-SELECT(3, S) → 返回 6
```

---

#### ✅ OS-RANK(x, S)：

> 返回元素 `x` 在集合 `S` 中的**排名（即第几小）**。

举例：

```text
S = {2, 4, 6, 10, 13}
OS-RANK(10, S) → 返回 4（10 是第 4 小）
```

---

### 🤔 问题来了：怎么实现这两个操作很快？

最简单的思路是：每次排序、再找第i个或找位置。但是排序的时间是 `O(n log n)`，不高效。

---

### 🚀 解决方案：用红黑树 + 子树大小

#### 🔧 红黑树（Red-Black Tree）

它是一种 **自平衡二叉查找树（BST）**，支持：

- 插入、删除、查找时间复杂度是 `O(log n)`
    
- 树高不会退化成链，性能稳定
    

---

#### 💡 扩展：在每个节点里多维护一个 `size` 字段：

```text
每个节点结构：
  key：该节点的值
  size：以该节点为根的子树中**节点总数**
```

比如：

```
        [10|5]
       /      \
   [5|2]     [13|1]
   /
[2|1]
```

- 根节点是 10，子树有5个节点 → size=5
    
- 节点 5，有2个节点（自己 + 左子）→ size=2
    
- 节点 2，没子 → size=1
    
- 节点 13，无子 → size=1
    
得到增强版红黑树

---

### 🧠 如何用这些 size 实现两个操作？

---

#### 📍 OS-SELECT(i, x)

在红黑树中找第 `i` 小元素的思路如下：

```text
设节点 x 的左子树大小为 L = x.left.size
```

- 如果 `i == L + 1` → 当前节点 `x` 就是第 i 小，返回它
    
- 如果 `i < L + 1` → 第 i 小一定在左子树中，递归左边
    
- 如果 `i > L + 1` → 第 i 小一定在右子树中，递归右边，但注意要减去左边和当前这1个：
    

```text
递归查找 x.right，查的是第 i - L - 1 小的元素
```

---

#### 📍 OS-RANK(x)

查找某个元素在集合中的“第几小”，也可以用 size 实现。

从 `x` 往上回溯，累加“当前节点左子树的 size + 当前节点是否在右子树”

思路如下：

```text
设节点 x，初始 rank = x.left.size + 1

往上走，如果 x 是其父节点的右子节点：
  → 说明比父节点的左子树 + 父节点还要大
  → rank += 父.left.size + 1
```

最后得到的 rank 就是它在整棵树中排第几。

（理解这个处理过程！）

## 区间树

### 🧠 问题背景：为什么我们需要增强数据结构？

你现在要解决的问题是这样：

❓ 给定很多区间，怎么快速查出「谁和我重叠」？

比如你有这些时间段：

- [5, 11]
    
- [4, 8]
    
- [15, 18]
    
- [17, 19]
    
- [22, 23]
    

然后你来一个新时间段：**[7, 10]**，你想问：

> 哪些已有的时间段和 [7, 10] 有交集？

这个问题很常见，比如：

- 日程冲突检测
    
- 视频片段重叠检测
    
- 时间线事件匹配
    
- 区域范围判断（地图、游戏）
    

---

### ❌ 如果没有增强结构，会怎么样？

你就只能暴力一个个去查：

```python
for interval in intervals:
    if overlap(interval, query): 
        return interval
```

- `overlap([a,b], [x,y])` 意思是：两段区间是否有交集。
    
- 时间复杂度是 **O(n)**，因为你要查所有区间。
    

**→ 如果有很多区间怎么办？慢！**

---

### ✅ 所以我们要用增强结构：**区间树（Interval Tree）**

#### 🌳 它是一个增强版的「红黑树 / BST（平衡二叉搜索树）」

- 每个节点存一个区间 `[low, high]`
    
- 你按 `low` 排序插入它
    
- **重点是：每个节点额外维护一个值：`max`**
    

#### 什么是 `max`？

- 它表示：**以当前节点为根的整个子树中，区间右端点 `high` 的最大值**
    
- 用来剪枝，减少不必要的搜索
    

---

### 🔍 查询时怎么做？

比如现在你查：[7, 10]

从根节点开始判断：

如果当前节点的区间和查询有交集 → ✅ 直接返回！

如果当前节点的左子树的 `max` ≥ 7 → 那就说明左子树「可能」还有能匹配的 → 进入左子树查！

否则去右子树。

这样每次查只需访问少量节点，**查询时间是 O(log n)**（如果树平衡），非常快！

---

### ✅ 例子讲解（结合你写的）

已有区间：

- [5, 11]
    
- [4, 8]
    
- [15, 18]
    
- [17, 19]
    
- [22, 23]
    

查询：[7, 10]，我们逐步找：

- [5, 11] ✅，它覆盖 7~10
    
- [4, 8] ✅，它也交叉 7~8
    
- 其它都不行，因为 `low > 10`
    

---

### 🌟 为什么这叫“增强”数据结构？

> 原本的 BST 只能根据单个值查找，现在我们加了 `max` 字段，让它可以支持复杂查询（区间重叠）！

这就是“增强（augmenting）”的精髓：**加一点额外信息，让原结构支持新能力，且仍然高效！**

---

### 📌 总结一句话

> 区间树是增强了“最大 high 值”的平衡二叉搜索树，用来高效地查找**所有和某区间重叠的区间**，适用于日程、地理、视频、事件等领域。

### ？是否还有别的算法能够解决？

#### 扫描线算法？

#### 维护两棵树

左端点一棵树，右端点一棵树，检索


