你提到的几个锁分别是：

1. **偏向锁（Biased Lock）**
    
2. **轻量级锁（Lightweight Lock）**
    
3. **重量级锁（Heavyweight Lock，也叫 Monitor Lock）**
    

它们是 Java 中 `synchronized` 锁在 **JVM 内部为了提升性能** 所做的 **锁优化机制**，由 JVM 自动控制和升级。下面详细对比它们的 **区别、适用场景和原理**：

---

## 一、三种锁的对比

|特性|偏向锁（Biased Lock）|轻量级锁（Lightweight Lock）|重量级锁（Heavyweight Lock）|
|---|---|---|---|
|是否阻塞|否|否（自旋）|是（线程挂起，等待操作系统调度）|
|性能开销|最低|中等|最高|
|适用场景|无线程竞争|少量线程竞争|多线程高竞争|
|实现方式|对象头中记录线程 ID|使用 CAS 操作 + 自旋|使用 `Monitor` + OS 阻塞唤醒|
|线程切换|无|无（或少量）|有（挂起/唤醒开销大）|
|触发条件|无竞争|有轻度竞争|有严重竞争|
|升级条件|其他线程尝试获取锁|自旋失败（多线程 CAS 失败）|不可降级|

---

## 二、三者的工作机制详解

### 1. 偏向锁（Biased Lock）

- **适用：单线程反复加锁解锁**
    
- 当一个线程第一次获取锁时，对象头中的 `Mark Word` 会**记录该线程 ID**。
    
- 之后**该线程再进入锁，不需要任何同步原语（如 CAS）**，提升性能。
    
- 如果有另一个线程尝试获取这个锁，**撤销偏向锁并升级为轻量级锁**。
    

### 2. 轻量级锁（Lightweight Lock）

- **适用：线程间有“少量竞争”**
    
- 线程尝试加锁时，不立即阻塞，而是通过 **CAS 将锁对象复制到栈帧中**。
    
- 如果 CAS 成功，就说明获取锁成功（无阻塞）。
    
- 如果 CAS 失败（代表有竞争），会进入**自旋（循环等待）**阶段，尝试再次获取锁。
    
- **自旋失败** → 升级为重量级锁。
    

### 3. 重量级锁（Heavyweight Lock / Monitor）

- **适用：多线程频繁竞争**
    
- 线程直接阻塞，由操作系统进行调度。
    
- 性能开销大（上下文切换、线程阻塞/唤醒代价高）。
    
- 会出现**线程挂起和唤醒操作**，适用于高竞争时确保安全。
    

---

## 三、演变流程（锁升级过程）

1. 初始为 **无锁状态**
    
2. 第一次加锁 → **偏向锁**
    
3. 其他线程竞争 → **轻量级锁**
    
4. 多线程同时竞争失败 → **重量级锁**
    

JVM 会自动**从低到高升级锁类型**，**不会自动降级**。

---

## 四、总结

- 偏向锁：单线程优化，**几乎无开销**
    
- 轻量级锁：轻量竞争下仍**避免阻塞**，用**CAS + 自旋**
    
- 重量级锁：**高竞争场景**使用，牺牲性能换取正确性

![[Pasted image 20250518172614.png]]