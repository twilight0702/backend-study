# 数据类型

## **1. 整数类型**

| 类型          | 字节数 | 范围（有符号）   | 特点                |
| ------------- | ------ | ---------------- | ------------------- |
| TINYINT       | 1字节  | -128 ~ 127       | 适用于非常小的整数  |
| SMALLINT      | 2字节  | -32,768 ~ 32,767 | 小范围整数          |
| MEDIUMINT     | 3字节  | -8百万 ~ 8百万   | 中等整数，使用不多  |
| INT / INTEGER | 4字节  | -21亿 ~ 21亿     | **最常用**          |
| BIGINT        | 8字节  | 超大整数         | 处理大ID/金额等场景 |

**可选属性：**

1. **显示宽度**

可以指定显示宽度，例如INT(5)，存入42，会显示00042；存入123456，显示123456（正常全部显示），但是实际存储的位数取决于类型而不是显示宽度。注意需配合ZEROFILL使用，表示用“0”填满宽度，否则指定显示宽度无效。

但从 MySQL 8.0.17 开始，显示宽度被废弃，不再推荐使用，**MySQL 以后会忽略它**。建议直接用 `INT`、`BIGINT` 等整型类型，不要再加 (M)。

整型数据类型可以在定义表结构时指定所需要的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度值。

TINYINT有符号数和无符号数的取值范围分别为-128 ~ 127和0 ~ 255，由于负号占了一个数字位，因此TINYINT默认的显示宽度为4。同理，其他整数类型的默认显示宽度与其有符号数的最小值的宽度相同。

int类型默认显示宽度为int(11)，无符号int类型默认显示宽度为int(10)

```sql
CREATE TABLE t1 (
  id INT(5) ZEROFILL
);
```

2. **UNSIGNED**

   可加 `UNSIGNED` 来扩展正数范围，例如：`INT UNSIGNED` 0 ~ 42亿。

3. **ZEROFILL**

   0填充，如果某列是ZEROFILL，那么MySQL会自动为当前列添加UNSIGNED属性，如果指定了ZEROFILL只是表示不够M位时，用0在左边填充，如果超过M位，只要不超过数据存储范围即可。int(M)必须和UNSIGNED ZEROFILL一起使用才有意义。

------

## **2. 浮点和定点类型**

| 类型         | 占用字节数 | 精度         | 特点                         | 适用场景               |
| ------------ | ---------- | ------------ | ---------------------------- | ---------------------- |
| FLOAT(M,D)   | 4          | 单精度       | 精度有限、快                 | 对精度要求不高的计算   |
| DOUBLE(M,D)  | 8          | 双精度       | 精度更高                     | 更精确的计算           |
| DECIMAL(M,D) |            | 高精度定点数 | **精度非常高**，但计算速度慢 | **财务、金额计算优选** |

> M = 总位数，D = 小数位数。例如：`DECIMAL(10,2)` 表示最大10位数，保留2位小数。

REAL默认是 DOUBLE。如果你把 SQL 模式设定为启用“ REAL_AS_FLOAT ”，那 么，MySQL 就认为REAL 是 FLOAT。如果要启用“REAL_AS_FLOAT”，可以通过以下 SQL 语句实现：

```sql
SET sql_mode = “REAL_AS_FLOAT”;
```

- 浮点数类型的无符号数取值范围，只相当于有符号数取值范围的一半，也就是只相当于有符号数取值范围大于等于零的部分，因为 MySQL 存储浮点数的格式为： 符号(S) 、 尾数(M) 和 阶码(E) ，无论有没有符号，MySQL 的浮点数都会存储表示符号的部分。

- MySQL允许使用 非标准语法 （其他数据库未必支持，因此如果涉及到数据迁移，则最好不要这么用）： FLOAT(M,D) 或 DOUBLE(M,D) 。这里，M称为 精度 ，D称为 标度 。(M,D)中 M=整数位+小数位，D=小数位。 D<=M<=255，0<=D<=30。
  - 例如，定义为FLOAT(5,2)的一个列可以显示为-999.99-999.99。如果超过这个范围会报错。
- FLOAT和DOUBLE类型在不指定(M,D)时，默认会按照实际的精度（由实际的硬件和操作系统决定）来显示。
- 浮点类型也可以加 UNSIGNED ，但是不会改变数据范围，例如：FLOAT(3,2) UNSIGNED仍然只能表示0-9.99的范围。
- 不管是否显式设置了精度(M,D)，这里MySQL的处理方案如下：
  - 如果存储时，整数部分超出了范围，MySQL就会报错，不允许存这样的值
  - 如果存储时，小数点部分若超出范围，就分以下情况：
    - 若四舍五入后，整数部分没有超出范围，则只警告，但能成功操作并四舍五入删除多余的小数位后保存。例如在FLOAT(5,2)列内插入999.009，近似结果是999.01。
    - 若四舍五入后，整数部分超出范围，则MySQL报错，并拒绝处理。如FLOAT(5,2)列内插入999.995和-999.995都会报错。

- 从MySQL 8.0.17开始，FLOAT(M,D) 和DOUBLE(M,D)用法在官方文档中已经明确不推荐使用，将来可能被移除。另外，关于浮点型FLOAT和DOUBLE的UNSIGNED也不推荐使用了，将来也可能被移除。在 8.0 中，推荐直接使用 `FLOAT` 或 `DOUBLE`，不加 `(M, D)`。
- 浮点数存在精度误差，避免使用“=”判断两个数字是否相等

---

使用 DECIMAL(M,D) 的方式表示高精度小数。其中，M被称为精度，D被称为标度。0<=M<=65，0<=D<=30，D<M。例如，定义DECIMAL（5,2）的类型，表示该列取值范围是-999.99~999.99。

**DECIMAL(M,D)**的最大取值范围与**DOUBLE**类型一样，但是有效的数据范围是由M和D决定的。

DECIMAL 的存储空间并不是固定的，由精度值M决定，总共占用的存储空间为M+2个字节。也就是说，在一些对精度要求不高的场景下，比起占用同样字节长度的定点数，浮点数表达的数值范围可以更大一些。

定点数在MySQL内部是以 字符串 的形式进行存储，这就决定了它一定是精准的。

当DECIMAL类型不指定精度和标度时，其默认为DECIMAL(10,0)。当数据的精度超出了定点数类型的

精度范围时，则MySQL同样会进行四舍五入处理。

------

## **3. 字符串类型**

### 定长 & 变长

| 类型       | 长度 | 特点                                                         |
| ---------- | ---- | ------------------------------------------------------------ |
| CHAR(M)    | M    | **定长字符串**，不足右补空格，读取快，检索的时候会去除末尾的空格 |
| VARCHAR(M) | M    | **变长字符串**，按实际存储节省空间                           |

> CHAR(n) 若未指定n，默认为1个字符，最大长度255
>
> VARCHAR 必须指定最大长度，最多 65535 字节（受行最大长度限制）。

- 限制的n是字符数，不是字节数，实际字节数取决于字符集

- 当MySQL检索CHAR类型的数据时，CHAR类型的字段会去除尾部的空格，（如果存储的字符串本身末尾有空格，也会被删除！）

- 检索VARCHAR类型的字段数据时，会保留数据尾部的空格。

### 文本类型（文本内容较大时使用）

| 类型       | 最大长度 | 特点       |
| ---------- | -------- | ---------- |
| TINYTEXT   | 255 字节 | 非常短文本 |
| TEXT       | 64KB     | 常用长文本 |
| MEDIUMTEXT | 16MB     | 更长文本   |
| LONGTEXT   | 4GB      | 超大文本   |

> 这些类型不支持默认值和全文索引（除非使用特定引擎如 InnoDB + utf8mb4 + 5.6+ 版本）。

在向TEXT类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。

由于实际存储的长度不确定，MySQL 不允许 TEXT 类型的字段做主键。遇到这种情况，你只能采用 CHAR(M)，或者 VARCHAR(M)。

TEXT文本类型，可以存比较大的文本段，搜索速度稍慢，因此如果不是特别大的内容，建议使用CHAR， VARCHAR来代替。还有TEXT类型不用加默认值，加了也没用。而且text和blob类型的数据删除后容易导致 “空洞”，使得文件碎片比较多，所以频繁使用的表不建议包含TEXT类型字段，建议单独分出去，单独用 一个表。

------

## **4. 二进制类型**

主要用来存储非文本的原始数据，也就是计算机底层看的“字节流”

| 类型                | 最大长度                                           | 特点         |
| ------------------- | -------------------------------------------------- | ------------ |
| BINARY(n)           | 定长二进制                                         | 类似 CHAR    |
| VARBINARY(n)        | 变长二进制                                         | 类似 VARCHAR |
| TINYBLOB ~ LONGBLOB | 和 TEXT 类似，但**存储二进制数据**（如图片、文件） |              |

n指的是字节数，BINARY(n)不指定默认1，如果字段值不足(M)个字节，将在右边填充'\0'以补齐指定长度。

VARBINARY类型的数据除了存储数据本身外，还需要1或2个 字节来存储数据的字节数。VARBINARY类型 必须指定(M) ，否则报错。

在实际工作中，往往不会在MySQL数据库中使用BLOB类型存储大对象数据，通常会将图 片、音频和视频文件存储到 服务器的磁盘上 ，并将图片、音频和视频的访问路径存储到MySQL中。

- ① BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值 会在数据表中留下很大的" 空洞 "，以后填入这些"空洞"的记录可能长度不同。为了提高性能，建议定期 使用 OPTIMIZE TABLE 功能对这类表进行 碎片整理 。
- ② 如果需要对大文本字段进行模糊查询，MySQL 提供了 前缀索引 。但是仍然要在不必要的时候避免检 索大型的BLOB或TEXT值。例如，SELECT * 查询就不是很好的想法，除非你能够确定作为约束条件的 WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值。 
- ③ 把BLOB或TEXT列 分离到单独的表 中。在某些环境中，如果把这些数据列移动到第二张数据表中，可 以让你把原数据表中的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会 减少主表中的 碎片 ，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行 SELECT * 查询的时候不会通过 网络传输大量的BLOB或TEXT值。

------

## **5. 日期时间类型**

| **类型**  | **名称**  | **字节** | **日期格式**        | **最小值**              | **最大值**              |
| --------- | --------- | -------- | ------------------- | ----------------------- | ----------------------- |
| YEAR      | 年        | 1        | YYYY或YY            | 1901                    | 2155                    |
| TIME      | 时间      | 3        | HH:MM:SS            | -838:59:59              | 838:59:59               |
| DATE      | 日期      | 3        | YYYY-MM-DD          | 1000-01-01              | 9999-12-03              |
| DATETIME  | 日期 时间 | 8        | YYYY-MM-DD HH:MM:SS | 1000-01-01 00:00:00     | 9999-12-31 23:59:59     |
| TIMESTAMP | 日期 时间 | 4        | YYYY-MM-DD HH:MM:SS | 1970-01-01 00:00:00 UTC | 2038-01-19 03:14:07 UTC |

> `TIMESTAMP` 常用于记录插入或更新时间，配合 `DEFAULT CURRENT_TIMESTAMP` 使用。

**TIME** 类型，不光表示一天之内的时间，而且可以用来表示一个时间间隔，这个时间间隔可以超过 24 小时。

**YEAR：**

```sql
INSERT INTO test_year VALUES('2020','2021'); # 插入YEAR
```

**DATE：**

以 YY-MM-DD 格式或者 YYMMDD 格式表示的字符串日期，此格式中，年份为两位数值或字符串满足

YEAR类型的格式条件为：当年份取值为00到69时，会被转化为2000到2069；当年份取值为70到99

时，会被转化为1970到1999。

使用 CURRENT_DATE() 或者 NOW() 函数，会插入当前系统的日期。（其他类型同理）

**TIMESTAMP 存储数据的时候需要对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时区。因此，使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间**

| 类型        | 存的时候      | 查的时候       | 适用场景                       |
| ----------- | ------------- | -------------- | ------------------------------ |
| `TIMESTAMP` | 自动转 UTC 存 | 查询时再转回来 | 适合存**操作记录时间戳**       |
| `DATETIME`  | 原样存        | 原样查         | 适合存**固定时间点**（如生日） |

TIMESTAMP存储空间比较小，表示的日期时间范围也比较小
底层存储方式不同，TIMESTAMP底层存储的是毫秒值，距离1970-1-1 0:0:0 0毫秒的毫秒值。
两个日期比较大小或日期计算时，TIMESTAMP更方便、更快。
TIMESTAMP和时区有关。TIMESTAMP会根据用户的时区不同，显示不同的结果。而DATETIME则只能
反映出插入时当地的时区，其他时区的人查看数据必然会有误差的。

------

## **6. 枚举类型（ENUM）**

- 只能存储指定的一组值之一（如：`ENUM('男','女','保密')`）

- 底层按数字存储，节省空间，**适合状态/类别字段**

- 存储空间：

  - 当ENUM类型包含1～255个成员时，需要1个字节的存储空间； 
  - 当ENUM类型包含256～65535个成员时，需要2个字节的存储空间。 
  - ENUM类型的成员个数的上限为65535个。

  ``` sql
  CREATE TABLE test_enum(
  season ENUM('春','夏','秋','冬','unknow')
  );
  
  INSERT INTO test_enum
  VALUES('春'),('秋');
  # 忽略大小写
  INSERT INTO test_enum
  VALUES('UNKNOW');
  # 允许按照角标的方式获取指定索引位置的枚举值
  INSERT INTO test_enum
  VALUES('1'),(3);
  # Data truncated for column 'season' at row 1
  INSERT INTO test_enum
  VALUES('ab');
  # 当ENUM类型的字段没有声明为NOT NULL时，插入NULL也是有效的
  INSERT INTO test_enum
  VALUES(NULL);
  ```

  索引从1开始

------

## **7. 集合类型（SET）**

- SET表示一个字符串对象，可以包含0个或多个成员，但成员个数的上限为 64 。（底层存储的也是数字）
- 可以从指定的多个值中**选择多个值组合**
- 例如：`SET('游泳','爬山','打球')` 可同时存储 '游泳,打球'

```sql
CREATE TABLE test_set(
s SET ('A', 'B', 'C')
);

INSERT INTO test_set (s) VALUES ('A'), ('A,B');
#插入重复的SET类型成员时，MySQL会自动删除重复的成员
INSERT INTO test_set (s) VALUES ('A,B,C,A');
#向SET类型的字段插入SET成员中不存在的值时，MySQL会抛出错误。
INSERT INTO test_set (s) VALUES ('A,B,C,D');
```

------

## **8. JSON 类型**

JSON（JavaScript Object Notation）是一种轻量级的 数据交换格式 。简洁和清晰的层次结构使得 JSON 成 为理想的数据交换语言。它易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效 率。JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻 松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式。

当需要检索JSON类型的字段中数据的某个具体值时，可以使用“->”和“->>”符号。

```sql
CREATE TABLE user_info (
    id INT PRIMARY KEY,
    info JSON
);

INSERT INTO user_info (id, info)
VALUES (1, '{"name": "Alice", "age": 25, "hobbies": ["reading", "coding"]}');

-- 提取 name 字段（注意用 → 运算符）
SELECT info->'$.name' AS name FROM user_info;

-- 提取 age（返回文本）
SELECT JSON_UNQUOTE(info->'$.age') AS age FROM user_info;
```

如果你遇到字段不固定、嵌套结构、或需要与前端 JSON 格式对接的数据 —— 就大胆用 `JSON` 类型，它结构清晰、灵活强大，还有丰富的函数支持。

------

## **9. 空间类型（GIS数据）**

适合地理信息应用，支持空间索引与空间操作函数（如距离计算）：

- **单值类型**：`POINT`、`LINESTRING`、`POLYGON`
- **集合类型**：`MULTIPOINT`、`MULTILINESTRING`、`MULTIPOLYGON`

------

## 常见小技巧

| 应用场景             | 推荐类型                                  |
| -------------------- | ----------------------------------------- |
| 主键 ID              | `INT UNSIGNED AUTO_INCREMENT` 或 `BIGINT` |
| 金额、精确度高的数值 | `DECIMAL(10,2)`                           |
| 状态字段             | `ENUM('待处理','已完成','已取消')`        |
| 长文本（如文章）     | `TEXT`                                    |
| 图片/文件            | `BLOB`                                    |
| 创建时间             | `TIMESTAMP DEFAULT CURRENT_TIMESTAMP`     |

## 10. 位类型

| 类型   | 长度 | 长度范围     | 占用空间            |
| ------ | ---- | ------------ | ------------------- |
| BIT(M) | M    | 1 <= M <= 64 | 约为(M + 7)/8个字节 |

BIT类型，如果没有指定(M)，默认是1位。这个1位，表示只能存1位的二进制值。这里(M)是表示二进制的位数，位数最小值为1，最大值为64。

注意：在向BIT类型的字段中插入数据时，一定要确保插入的数据在BIT类型支持的范围内。

MySQL 在插入正整数时，会把整数自动转成二进制存（如果转化后超位数了会报错，负整数直接报错），可以在存之前显式转换，或者直接存二进制串

```sql
INSERT INTO test_bit1(f1) VALUES(b'1'); 
```

查询默认返回的是二进制串

| 查询方式         | 说明                     | 示例结果（存的是 b'1101'） |
| ---------------- | ------------------------ | -------------------------- |
| `SELECT b1`      | 显示原始二进制（乱码）   | 二进制字节                 |
| `SELECT BIN(b1)` | 转为“二进制字符串”       | `'1101'`                   |
| `SELECT HEX(b1)` | 转为“十六进制字符串”     | `'0D'`                     |
| `SELECT b1 + 0`  | 当作整数读出来（十进制） | `13`                       |

